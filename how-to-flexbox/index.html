<!DOCTYPE html>
<html>
  <head>
    <title>Как работать с Flexbox</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Roboto);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Roboto';
        line-height: 25px;}
      h1, h2, h3 {
        font-family: 'Roboto';
        font-weight: normal;
        line-height: 40px;
      }
      h1 {
        margin: 15px 0;
      }
      h4, h5, h6 {
        margin: 10px 0;
      }
      img {
        width: 100% !important;
      }
      li {
        margin-bottom: 5px;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }
    </style>
  </head>
  <body>
    <textarea id="source">
# Flexbox
**Flexbox** - подмножество CSS-правил, контролирующие взаимное расположение элементов на странице.

Flexbox позволяет каждому контейнеру самому решать, как будут расположены его дочерние элементы

_Контейнер_ - любой элемент, который может содержать детей.  
`<div>`, `<ul>`, `<strong>` и т.п. - контейнеры  
`<link/>`, `<br/>` - не контейнеры  

Поиграться со свойствами, описанными далее, можно, перейдя по следующей ссылке:  
https://codepen.io/osublake/full/dMLQJr/  
или коротенькой `bit.ly`:  
https://bit.ly/2mT1GjJ  
---

## flex-контейнер
Это контейнер, у которого задано свойство `display: flex`

![](https://cdn-images-1.medium.com/max/1000/1*L2W-ziqU45a1BNWV79ijDQ.gif)

---

Отличительными особенностями является наличие воображаемых осей: главной и поперечной. Эти оси проходят через центр контейнера и перпендикулярны друг другу.

![](https://cdn-images-1.medium.com/max/800/1*_Ruy6jFG7gUpSf76IUcJTQ.png)

---

### Оси flex-контейнеров
По умолчанию главная ось является горизонтальной, поперечная - вертикальной.

Дочерние элементы располагаются вдоль главной оси

Изменить направление главной оси (а значит, и поперечной) позволяет свойство `flex-direction`, устанавливаемое у flex-контейнеров.

_Не имеет эффекта у обычных контейнеров, как и другие свойства flex-контейнеров_

**Обратите внимание, что задавая свойство flex-direction вы не заставляете элементы строиться вдоль поперечной оси, вы поворачиваете оси**

---

#### Значения flex-direction
* `row` (строка, по умолчанию)
* `column` (столбец)
* `row-reverse` и `column-reverse` (то же самое, что и первые два, но элементы расположены в обратном порядке)

![](https://cdn-images-1.medium.com/max/1000/1*4yKnG2-vuPF5XA-BmXADLQ.gif)

---

### Выравнивание относительно главной оси
Это контролируется свойством `justify-content` (примерный перевод - _установить пространство между содержимым_) для flex-контейнеров

**Значения justify-content**

* `flex-start` (в начале, по умолчанию)
* `flex-end` (в конце)  
**Обратите внимание на то, что порядок элементов не изменился**
* `center` (по центру)
* `space-between` (пространство между [элементами])
* `space-around` (пространство вокруг [элементов])

![](https://cdn-images-1.medium.com/max/1000/1*2-6Tw8jqWrMKOfIugKyuDA.gif)

---

### Выравнивание относительно поперечной оси
Это контролируется свойством `align-items`, задаваемого контейнеру.

**Значения align-items**

* `flex-start` (в начале, по умолчанию)
* `flex-end` (в конце)
* `center` (по центру)
* `stretch` (растянуть)
* `baseline` ("основная линия")

![](https://cdn-images-1.medium.com/max/1000/1*htfdNmRIIFu_veRaFOj5qA.gif)

---

#### Насчет `baseline`
Если бы в элементах не было параграфов (`&lt;p>`), то выравнивание произошло бы по нижней линии самих элементов

На практике, однако, это свойство почти не используется, поэтому особо заморачиваться по поводу него не стоит

![](https://cdn-images-1.medium.com/max/1000/1*6dd9KnKMUN49lFsbHlJi6A.png)

---

### Выравнивание конкретных элементов
Это контролируется свойством `align-self`, задаваемого элементу.

**Значения align-self совпадают со значениями align-items**

![](https://cdn-images-1.medium.com/max/1000/1*HIADl1oL6pxXb2dMh_pXSQ.gif)

---

### Перенос элементов
По умолчанию, flex-контейнер будет **сжимать своих детей!!!**, пока они не уместятся внутри него.

![](https://screenshots.firefoxusercontent.com/images/2d1fdb82-0166-4ea9-8166-330f14a378a2.png)

Можно, однако, настроить перенос на новую строку (соответственно, с расширением контейнера в направлении поперечной оси).
Делается это с помощью свойства `flex-wrap`, задаваемого flex-контейнеру.

**Значения flex-wrap**:

* `nowrap` (не переносить и сжимать, по умолчанию)
* `wrap` (переносить)
* `wrap-reverse` (переносить в обратном порядке)

---
### Взаимное расположение строк
Когда происходит перенос, возникает две строки и вопрос: как их контролировать?

Каждая строка соблюдает правила главной оси, установленные для flex-контейнера

Сами строки друг относительно друга можно располагать свойством `align-content`, имеющим значения, очень схожие с `justify-content`.
Настолько схожие, что они абсолютно идентичны, за исключением значения `stretch`, доступного для `align-content` помимо всего прочего

---

### Передышка и немного практики

---

## Адаптивный дизайн с помощью Flexbox
Вот это - не адаптивный дизайн:
![](https://screenshots.firefoxusercontent.com/images/fb24e108-1c3c-42c3-a887-bf1655680a84.png)

---

### Начальный размер по главной оси
Для того, чтобы задать размеры элементов, можно использовать традиционные `width` и `height` или свойство `flex-basis` у элемента

Отличие `flex-basis` заключается в том, что направление главной оси определяет то, будет это ширина или высота для элемента

Значениями `flex-basis` могут быть все допустимые значения свойства `width`, а также `content` (размер определяется содержимым элемента)

![](https://cdn-images-1.medium.com/max/1000/1*W4QU1Fw9kDLEH2m-J9VGyw.gif)
---

### Изменение начальных размеров
Если все элементы не могут заполнить своими размерами все пространство контейнера, то по желанию каждый элемент может вырасти в размерах

Это контролируется свойством `flex-grow` для элемента  
**Значение `flex-grow` - относительная величина!**  
По умолчанию у всех элементов `flex-grow` равно 0, что запрещает элементу расти для заполнения контейнера

До:
![](https://cdn-images-1.medium.com/max/1000/1*dON3-0RooiPyfDr0DBEOmA.png)
После:
![](https://cdn-images-1.medium.com/max/1000/1*cK-yB4z_L6bmEqoG5qDoRA.png)

---

Если суммарный размер элементов больше, чем позволяет вместить контейнер, то по желанию каждый элемент может сужаться

Аналогично `flex-grow`, сжатие элемента контролируется свойством `flex-shrink`. Это также относительная величина, и по умолчанию у всех элементов она равна 1, т. е. все элементы одинаково сжимаются, чтобы поместиться в контейнере

![](https://cdn-images-1.medium.com/max/1000/1*FVO9kX3wwqakhcT9JWS2Ww.gif)

---

### Укороченное свойство `flex`
Чтобы не приходилось писать много текста, у элементов flex-контейнеров есть свойство `flex`

Его запись выглядит следующим образом:

`flex: [flex-grow] [flex-shrink] [flex-basis]`

где на месте квадратных скобок значения соответствующих свойств.

Это выделяет еще одно маленькое приемущество `flex-basis` над `width` и `height` - можно меньше писать :)

![](https://cdn-images-1.medium.com/max/1000/1*BKZt7AT5eFee4KRhe82gew.gif)

---

Важно понимать, что если у одного элемента `flex-grow` равен 2, а у другого - 1, то второй элемент не вырастет до половины размера первого.

Суть отношений значений `flex-grow` и `flex-shrink` в скорости растяжения/сжатия.

На следующем изображении в этот раз для наглядности прописаны значения ширины контейнера, а также отличие ширины от `flex-basis` (дельта)
_Обратите внимание, что тут для элементов установлен еще и_ `margin: 10px`

![](https://s1.gifyu.com/images/ezgif-4-2f2f15476f.gif)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
