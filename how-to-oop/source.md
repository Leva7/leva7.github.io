# Объектно-ориентированное программирование

## Немного повторения (или...)
_Класс_ - формальное описание чего-либо, выделяющее те его аспекты, которые важны в данном контексте (при решении данной задачи).
Класс порождает объекты.

В дальнейшем может быть использовано слово "инстанс" (instance, экземпляр) для обращения к объектам класса. Делается это для того, чтобы отличать объект конкретного класса от просто объекта, а также чтобы для вас привычнее выглядели некоторые сообщения об ошибках в Python.

**Неформально**: класс - это чертеж, по которому вы можете построить сколько угодно объектов.

---

_Например_: в некоторой задаче важно, что у объекта четыре ножки. Остальные параметры нас не интересуют. В программировании мы можем создать такой объект, в реальной жизни - нет, потребуется больше информации.

Таким образом, при создании классов достаточно описать что-то абстрактное, обладающее требуемыми свойствами, описывать все свойства стола ни к чему (да и невозможно).

В нашем примере мы можем представить объект с четырьмя ножками как стол, стул, чихуахуа и т. д.

---

## Как мы хотим описать объект, о котором думаем?

- внешний вид (цвет, размеры)
- внутреннее состояние (текущее время)
- действия, которые может выполнять этот объект
- что-нибудь еще?

![](static/thinking.png)
---

Все пункты описания объектов можно разбить на две категории:
- данные
- алгоритмы

Мы привыкли использовать переменные для хранения данных и функции для записи алгоритмов. В ООП та же схема приобретает чуть другие названия:

* Переменные класса/объекта называются его _свойствами_
* Функции класса/объекта называются _методами_

_Поля_ класса/объекта - совокупность свойств и функций, для краткости.

---

## Лирическое отступление: каноны именования
Для того, чтобы названия в коде были понятными, они часто состоят из нескольких слов. Пробел в именах использовать нельзя, как тогда их разграничивать?

Есть три общепринятые схемы:

* `нижняяВерблюжьяНотация` (`lowerCamelCase`)
* `ВерхняяВерблюжьяНотация` (`UpperCamelCase`)
* `нижние_подчеркивания` (`underscores_name`)

В языке Python принято писать названия классов _верхней верблюжьей нотацией_, названия методов, функций, переменных - _нижними подчеркиваниями_.
Нижнюю верблюжью нотацию рекомендуется не использовать.

Каждый язык задает свои каноны именования.

---

## Как описать класс?
### Python
В Python описание класса начинается с ключевого свойства `class`, далее следует имя класса и двоеточие, после чего на следующем уровне отступов идет описание класса.

Синтаксис описания выглядит следующим образом:

```python
class ClassName:
    # Блок кода
    pass
```

---

### C++
В С++ описание класса начинается с ключевого свойства `class` или `struct` (о различиях поговорим позже), далее следует имя класса, затем блок кода в фигурных скобках и **точка с запятой**.

```cpp
struct ClassName
{
  // Блок кода
};
```

**Яростная заметка C++-программиста** (спасибо Егору Потапенко) - через ключевое слово `struct` описывается структура, а не класс. По канонам C++ структуры используются только для хранения данных, методы в них описывать можно, но не стоит.

---

## С неба на землю
Важно понимать, что, создав класс, вы **не переходите** на волшебную территорию, где неприменимы привычные правила и нужно действовать лишь по строгим указаниям.

Что это означает? То, что под "блоком кода" в прошлых примерах подразумевается действительно абсолютно произвольный блок кода.

В Python внутри описания классов можно:

* создавать переменные
* описывать функции
* импортировать другие библиотеки
* считать произвольные выражения
* _о боже_, описывать классы

---

```python
class A:
    from math import log2
    if log2(4) != 2:
        print('wait, what')

    for i in range(10):
        a = i + 1

    class B:
        pass

print(A.B)  # <class '__main__.A.B'>
print(log2(8))  # ой, NameError
```

Иными словами, это самый обыкновенный блок кода (из чего следует, что у него своя область видимости, поэтому на примере кода, приведенном выше, возникла ошибка при обращении к `log2`).

В C++ тоже можно творить все, что угодно, внутри описания, даже использовать директивы вроде `#include` (хотя понятия не имею, кому это может понадобиться).

---

## С земли на дно
В Python _класс - это объект_.

![](static/wat.jpg)

---

А объект, как правило, лежит в переменной. А что можно делать с переменной, думаю, объяснять не требуется.

```python
class A:
    # некоторое описание
    pass

B = A  # Ура, теперь есть класс B, абсолютно идентичный классу A
A = int  # Ура, теперь можно создавать числа с помощью класса A
B = 5  # Больше нет упоминаний о том классе, поэтому этот класс уничтожается
```

Функции, кстати, тоже объекты. Почти все в Python - это объекты.

---

## Давайте же создадим объект
Делается это просто - оператором вызова, примененным к объекту "класс". По аналогии, вызов функции - это применение оператора вызова к объекту "функция".

```python
class MyClass:
    # Пустой класс
    pass

a = MyClass()
         # ^^ - оператор вызова
```

Теперь у нас есть объект пустого класса. Естественно, он ничего не умеет и не несет информации.

---

## Жизненный цикл объекта

Для объекта есть три основных стадии жизни:

- создание
- существование
- уничтожение

На всех трех стадиях можно заставить объект выполнять какой-то код. Например, на этапе создания можно выставить некоторые свойства для этого конкретного объекта.

---

## Конструктор
При создании объекта вызывается особый метод класса - конструктор.
Особый он только названием, по сути от остальных методов он не отличается.

### C++
В этом языке конструктор называется именем класса, а также не имеет явного типа возвращаемого значения.

То есть, мы привыкли писать функции как-то так:
```cpp
ReturnType function_name() {}
```

---

Внутри класса можно описать конструктор так, без всякого `ReturnType`:
```cpp
struct Player
{
  Player(string name)
  {
    cout << "Hello, " << name << endl;
  }
};
```

Теперь при создании объекта в консоль будет печататься его имя:
```cpp
Player p = Player("Lev");  // выводится Hello, Lev
```

---

### Python
Python немного противоречив в этом плане, так как в качестве конструктора рекомендуется использовать метод `__init__`, который не является конструктором.

Конструктором в Python на самом деле является метод `__new__`, но он нас не интересует.

```python
class Player:
    def __init__(self, name):
        print('Hello,', name)

me = Player('Lev')  # выводится Hello, Lev
```

> Эй, а что еще за `self`? В примере C++ конструктор принимал только один аргумент, имя игрока!

---

Таким образом, мы подобрались к особенностям описания методов в Python.
Все (почти) методы принимают, по меньшей мере, один аргумент - объект, от которого вызывается метод.

Этому аргументу многолетними соглашениями было присвоено имя `self`. Вы не обязаны называть его именно так, но если вы назовете его по-другому, другие программисты вас, мягко говоря, не похвалят.

> Если вы так сделаете, люди будут вас ненавидеть, и вас будут презирать друзья и семья.  
  — Scott Chacon

---

Рассмотрим на примере. Как-то так могло бы выглядеть описание известного вам метода строк - `.count()`:
```python
class str:
    # ...
    def count(self, char):
        cnt = 0
        for i in self:
            if i == char:
                cnt += 1
        return cnt
    # ...
```

---

## Состояние объекта
Разумеется, просто выводить приветствие при создании объекта - не самое креативное применение для конструктора и вообще ООП.

В конструкторе мы можем, например, зафиксировать имя игрока, а также установить какое-нибудь состояние:

### Python
```python
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

me = Player('Lev')
print(me.name)  # Lev
me.inventory.append('money')  # Вызываем метод .append() класса list
```

---

```python
# Тот же код, дублирован для наглядности
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

me = Player('Lev')
```

Рассмотрим поподробнее, что же произошло в конструкторе
```python
self.inventory = []
```

Мы знаем, что `self` - наш инстанс класса Player (тот самый, что окажется в переменной `me` после выполнения конструктора)  
Что же случилось дальше? Дальше с помощью оператора доступа (точка) мы обратились к свойству `inventory` нашего инстанса. Это свойство находится в левой части присвоения, поэтому Python нисколько не смущает то, что он не нашел у инстанса свойство `inventory` - он его попросту создал.

Таким образом, мы научились создавать свойства и получать их значения.

---

#### Опять на землю
В этом куске кода тоже не было ничего, что может быть только в классе. Например, после создания объекта мы можем создать свойство лично у него:

```python
class Player:
    pass

me = Player()
me.name = 'Lev'

you = Player()
print(you.name)
```
> Но ведь у инстанса `you` нет имени...

Правильно, нет:  

`AttributeError: 'Player' object has no attribute 'name'`

---

А еще мы знаем, что по сути объект класса `Player` особо не отличается от объектов классов `list`, `str`, и т. д.
А это значит, что:

```python
ls = []
ls.name = 'My List'

def func():
    pass

func.name = 'My Function'

def show_name(obj):
    print(obj.name)

show_name(ls)  # My List
show_name(func)  # My Function
```

Но достаточно играться с динамической натурой Python.

---

### C++
В С++ все строго - для того, чтобы задать свойство, нужно его сначала объявить.

```cpp
struct Player
{
  string name;
  vector<string> inventory;  // По умолчанию инициализируется
                             // пустым вектором для каждого инстанса

  Player(string name)
  {
    this->name = name;
  }
};

int main()
{
  Player me = Player("Lev");  // Еще можно записать то же
                              // самое так: Player me("Lev");
  cout << me.name << '\n';  // Lev
  me.inventory.push_back("money");  // Вызываем метод push_back класса vector
}
```

---

> А это что за ужас, что за this, стрелочки какие-то, сложно...

Да, С++ не очень располагает к себе в этом плане.  
Внутри методов есть переменная `this`, являющаяся аналогом `self` в Python.  
Оператор "стрелочка" (`->`) - аналог оператора доступа "точка", но для указателей. Да, `this` - это только указатель на объект.

Таким образом, эту строку  
```cpp
this->name = name;
```  
можно было бы написать и так:  

`*(this).name = name;`

И тут уже нельзя будет написать что-то вроде этого без предварительного объявления внутри класса переменной `int health`.
```cpp
Player me = Player("Lev");
me.health = 100;
```

---

## Описание произвольных методов
Теперь, когда мы умеем описывать конструктор и сохранять в объекте данные, можно попробовать описать и другие методы.

Вернемся к нашему игроку:
```python
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

    def pick_up(self, item):
        self.inventory.append(item)

    def drop_stuff(self):
        self.inventory.clear()
```

---

И вот как с этим классом теперь можно обращаться:

```python
me = Player('Lev')
me.pick_up('money')  # Вызываем метод pick_up,
                     # передавая строку 'money' в качестве параметра

you = Player('Not Lev')
you.pick_up('knowledge')
you.pick_up('patience')

print(me.inventory, you.inventory)  # ['money'] ['knowledge', 'patience']
me.drop_stuff()
print(me.inventory == [])  # True
```

---

В С++ дела обстоят почти идентично, только аргументам методов нужно прописывать тип, а методам - тип возвращаемого значения:
```cpp
struct Player
{
  string name;
  vector<string> inventory;

  Player(string name)
  {
    this->name = name;
  }

  void pick_up(string item)
  {
    this->inventory.push_back(item);
  }
  // ...
};

// ...
```

---

## Упражнение, условие
Программист может осуществлять два вида деятельности:

1. Писать код.
2. Пить кофе.

Когда программист пишет код, он устает. Поэтому на каждую следующую строчку
кода он тратит больше времени, чем на предыдущую. Если программист выпивает
чашку кофе, он восстанавливает работоспособность, но, к сожалению, после каждой
чашки кофе начинает все быстрее уставать.  

Начинает писать код программист отдохнувшим, поэтому первую строчку кода пишет
за 1 минуту. Если он не будет пить кофе, то каждую следующую строчку кода он
будет писать на 1 минуту дольше, чем предыдущую.  

После написания любой строчки кода он может выпить чашку кофе. После того, как
программист выпьет чашку кофе, очередную строчку кода он опять напишет всего за
одну минуту, но на каждую последующую будет тратить уже на N минут больше, чем
на предыдущую, где N зависит от того, какая это по счету чашка кофе, выпитая
программистом. После первой выпитой чашки кофе, N становится равно 2, после
второй – 3, после третьей – 4, а после четвертой - 5. При этом на то, чтобы выпить
любую чашку кофе, программист тратит 5 минут.

---

## Упражнение, постановка задачи

Создать класс `Coder`, поддерживающий следующее состояние:

* кол-во написанных строк кода
* кол-во выпитых чашек кофе
* время, которое потратил программист, в минутах
* усталость (влияет на скорость написания кода)

Описать в нем методы:

* написать строку кода
* выпить чашку кофе
* информация (вывести "На момент времени {} написано {} строк кода и выпито {} чашек кофе", заменяя {} на соответствующие свойства класса)

Класс должен действовать в соответствии с условием задачи, описанным на предыдущем слайде.  
_Задание частично взято из тренировочной сессии ИТМО._

Сдать задание можно в [этот classroom](https://repl.it/classroom/invite/KZNtdaz), assignment "Уставший программист".

---

## Классовые свойства
Помните, шла речь о том, что в Python класс - это объект? Помимо развлечений с присваиваниями это позволяет создавать свойства, доступные для всех инстансов класса - _классовые свойства_

Классовые свойства можно задать следующими способами:

* определить внутри описания класса переменную
* записать ее в объект класса напрямую

---

Рассмотрим оба способа на примере:

```python
class DataCentre:
    dest_country = 'America'
    def send_data(self):
        print('Sending data to', self.dest_country)

data_centres = []
for i in range(100):
    data_centres.append(DataCentre())
```

По какой-то причине нам больше не хочется отсылать данные в Америку, а столько дата-центров уже создано...  
Можно, конечно, пробежать по стране и перенастроить каждый дата-центр отдельно:

```python
for dc in data_centres:
    dc.dest_country = 'Russia'
```

---

Но это долго и неудобно. Классовые свойства позволяют нам контролировать все инстансы из одного места - порождающего их класса:

```python
DataCentre.dest_country = 'Russia'
```

Теперь, если мы обратимся к любому уже созданному дата-центру или создадим новый, они все будут отправлять данные в Россию:

```python
data_centres[77].send_data()  # Sending data to Russia
DataCentre().send_data()  # аналогично
```

---

_Заметка_. Несколько ранее мы рассматривали пример нетрадиционного описания класса, но особо не интересовались теми самыми `print`'ами.  

В данном примере функция `log2` и класс `B` являются классовыми свойствами класса `A`, поэтому мы можем получить доступ к ним через оператор `.`.

```python
class A:
    from math import log2
    # ...
    class B:
        pass

print(A.B)  # <class '__main__.A.B'>
print(log2(8))  # ой, NameError
```

---

### А если перезаписать классовое свойство обычным?
Почему бы и нет. Оператор "точка" действует примерно по следующему алгоритму:

1. Ищи поле у инстанса
2. Ищи поле у класса этого инстанса
3. Ищи поле у суперкласса этого класса (об этом позже)
4. ...
5. Бросай исключение `AttributeError`

Если на одном из этих шагов требуемое поле будет найдено, поиск остановится. Поэтому если у отдельного инстанса вы перезапишете классовое свойство, то получите именно то, что ожидали:

```python
class DataCentre:
    dest_country = 'America'
    def send_data(self):
        print('Sending data to', self.dest_country)

dc = DataCentre()
dc.dest_country = 'Russia'
dc.send_data()  # Sending data to Russia
DataCentre().send_data()  # Sending data to America
```

---

### С++
Здесь похожий механизм реализован с помощью _статических свойств_.  

Чтобы сделать свойство статическим, достаточно дописать перед типом `static`:

```cpp
struct MyClass
{
  static int i;
};

int MyClass::i = 1337;

int main()
{
	MyClass obj;
	cout << obj.i << endl;
	cout << MyClass::i << endl;
}
```

---

Здесь важно понимать следующее: ввиду статичности языка C++ статические свойства объявлятся один раз и используются на протяжении всей программы.  

Поэтому:

1. внутри описания класса статические свойства на самом деле не объявляются  
2. реальное объявление можно сделать только в глобальной области видимости  

Почему так? Если мы объявляем переменную в функции (даже такой главной, как `main`), эта переменная доступна только там. А статические свойства глобальны вообще для всего файла. Поэтому нужно определить переменную вне всяких функций (спасибо Тимуру Гарифзянову).

---

Еще тут есть незнакомый синтакисис - два двоеточих:

```cpp
int MyClass::i = 1337;
```

В C++, так как классы являются типами, а не объектами, оператор "точка" для получения полей неприменим.  
Поэтому нужен аналог для типов, пространств имен (`std`, например) и прочего. Он называется _спецификатором области видимости_, то есть, по сути, сужает поиск имени справа в области видимости слева:

```cpp
scope::name
```

---

## Как из инстанса изменить классовое свойство?
Как мы видели ранее, при попытке записать классовое свойство через объект, создается новое свойство объекта, а свойство класса не меняется.

Как тогда изменить именно классовое свойство, чтобы все объекты получили изменение?

Есть вполне логичный способ - изменить это свойство напрямую у класса:
```python
DataCentre.dest_country = 'Russia'
```

Но бывают моменты, когда класс объекта неизвестен. Это явление связано с **полиморфизмом** - совпадающий интерфейс у разных классов.  

Например, в C++ у контейнеров есть метод `size()`. Вам не нужно знать, какой именно контейнер попал вам в руки, чтобы узнать его размер.

---

В Python можно во время исполнения кода узнать, какой класс породил данный объект. Делается это с помощью функции `type()`, принимающей объект и возвращающей класс.

Таким образом, обратиться к классу для изменения свойства можно, например, так:

```python
type(obj).prop = 1337
```

```python
>>> type('hello')
str
>>> type('hello')()
''
```

---

## Классовые методы?..
> Круто, есть классовые свойства, а классовые методы бывают?  

Бывают, но тут уже классовость проявляется по-другому.

Все методы любого класса являются функциями, а, значит, переменными, определенными при описании класса. То есть, _все методы, описанные внутри описания класса_ - классовые поля по определению.  
Вы, конечно, можете создать у инстанса поле и присвоить ему функцию - вы получите метод, присутствующий только у конкретного объекта. Зачем - непонятно, но можете.  

Что же тогда означает классовый метод и чем он отличается от неклассового? На самом деле, методы в Python бывают трех видов:

* инстансные (обычные)
* классовые
* статические

Их главное отличие - тот самый первый аргумент, который мы все привыкли называть `self`.  
Но прежде чем мы углубимся в различия, давайте научимся создавать эти методы.

---

Единственное отличие в определении - наличие _декоратора_ `classmethod` для классовых методов и `staticmethod` для статических.

> Ээм, декоратора?

Да, декораторы - это функции, являющиеся обертками вокруг других функций (декорируемых), позволяющие, например, изменить аргументы, передаваемые в функцию или совершить стороннее действие при каждом вызове.

Разговор о декораторах и о том, как их писать, выходит за рамки нашего обсуждения, сейчас важно то, что есть стандартные функции-декораторы `classmethod` и `staticmethod`.

Декораторы применяются к функциям с помощью следующего синтаксиса:
```python
@decorator
def func(arg1, arg2):
    # обычное описание функции
    pass
```
где `decorator` - функция-декоратор.

---

Рассмотрим на примере:
```python
class MethodsTest:
    def instancem(self):
        print(self)

    @classmethod
    def classm(cls):
        print(cls)

    @staticmethod
    def staticm():
        print("I'm independent!")
```

Вы можете заметить, что не все методы, описанные выше, принимают первый аргумент, а у одного он назван по-другому, что делать было, вроде как, очень нехорошо.

Оказывается, что для классовых методов принято называть первый аргумент `cls` (от слова `class`), а статический метод может вообще не принимать аргументов.

---

Собственно, уже этот факт намекает на отличие - классовым методам _в качестве первого аргумента передается не инстанс, а его класс_.  
Статическим методам вообще ничего не передается, они принимают только те аргументы, которые вы передаете при вызове внутри скобок.  

Давайте вызовем методы нашего класса `MethodsTest` и посмотрим на вывод:

```python
MethodsTest().instancem()  # <MethodsTest object at 0x72aa5ec>
MethodsTest().classm()  # <class 'MethodsTest'>
MethodsTest().staticm()  # I'm independent!
```

Таким образом, Python подтверждает все выше сказанное.  

Но вы можете заметить, что для вызова классового и статического метода всё равно создавался инстанс, который был уничтожен почти сразу после. Поэтому логичный вопрос:  
> ~~на~~ зачем?

Действительно, незачем. Эти методы тем и хороши, что могут вызываться напрямую от класса, избегая лишних расходов памяти:

```python
#MethodsTest.instancem()  обратите внимание, что так делать нельзя
MethodsTest.classm()
MethodsTest.staticm()  # а так - можно
```

---

> Ну и зачем мне это? Если я в методе не воспользуюсь аргументом `self`, я его просто проигнорирую

Хорошим тоном является превращение методов, не зависящих от состояния конкретного инстанса, в классовые.

Статические методы, как правило, используются просто как функции, по смыслу тесно связанные с классом, но никак с ним не взаимодействующие.

---

Например:

```python
class Downloader:
    folder = 'Downloads'
    def __init__(self, prefix):
        self.prefix = prefix
        self.downloaded = 0

    def download(self, url):
        # скачивание файла по URL
        filename = self.prefix + str(self.downloaded)
        # сохранение файла с именем filename
        self.downloaded += 1

    @classmethod
    def clear_downloads(cls):
        # удаление всех файлов из папки cls.folder
        pass

    @staticmethod
    def file_to_url(file):
        return 'site.com/' + file
```

---

## Инкапсуляция
Инкапсуляция - платьице на бульдоге. Иными словами, это попытки скрыть от внешнего мира свои программистские грехи, выдав пользователю красивый на вид интерфейс.  

Для чего это нужно?

* скрыть детали реализации, которые мало кого интересуют
* предотвратить неправильное, возможно, деструктивное применение (сделать вашу работу защищенной от дураков)

---

### Python
В Python нет инкапсуляции.
> стоп, что

Python-программистам скрывать нечего, они живут в гармонии и взаимопонимании.  

_Если поле класса начинается с нижнего подчеркивания, то не стоит его использовать напрямую_

_Если поле класса начинается с двух нижних подчеркиваний, то это прямо очень личное, не стоит вскрывать эту тему. Вы молодые, шутливые, вам все легко. Это не то. Это не Чикатило и даже не архивы спецслужб. Сюда лучше не лезть. Серьезно, любой из вас будет жалеть._

---

Но достаточно отдаленных от реальности фраз. На деле Python постарается спрятать поля, начинающиеся с двух земель (**здесь важно не перепутать такие поля с магическими методами вроде `__init__`, на них это ограничение не распространяется**).

```python
class HideMe:
    __secret_field = 1337
    def no_secrets(self):
        print(self.__secret_field)

HideMe().no_secrets()  # 1337
print(HideMe.__secret_field)  # AttributeError!
```

Может показаться, что показанный выше кусочек кода противоречит здравому смыслу.

Дело в том, что Python, защищая интересы автора класса `HideMe`, замаскировал поле `__secret_field` так, что вне класса оно доступно, но (как ни парадоксально) под другим именем:

```python
print(HideMe._HideMe__secret_field)  # 1337
```

---

Таким образом, вне класса к псевдо-приватному полю `__field` класса `Cls` можно получить доступ по имени: `_Cls__field`. Этот механизм называется _name mangling_ (_искажение имен_).

> А стоит ли оно того?

Да нет, как правило, обходятся без таких вынужденных мер. Но возможность такая всегда есть.

---

### C++
А вот тут все серьезно, инкапсуляция - важный механизм защиты от неопытных программистов.

Поля бывают:

- публичные (public)
- защищенные (protected)
- приватные (private)

_Публичные_ поля доступны всем и всегда.

_Защищенные_ поля доступны только внутри описания класса, а также внутри описаний классов-наследников (о механизме наследования позже).

_Приватные_ поля доступны только внутри описания класса.

---

Как-то давно говорилось о том, что между описанием класса и структуры есть одно различие - сейчас самое время его вспомнить.  
У структуры все поля по умолчанию публичные, у класса - приватные.

Но, конечно, можно контролировать, какие поля будут иметь какой уровень защищенности. Делается это следующим образом:

```cpp
class Example
{
  access_keyword:
    все поля, объявленные здесь, обладают уровнем защищенности access_keyword1
  access_keyword2:
    здесь - access_keyword2
};
```

На месте `access_keyword` могут быть ключевые слова:

* `public`
* `protected`
* `private`

В описании одного класса одно ключевое слово доступа может встречаться произвольное кол-во раз.

---

#### Пример
```cpp
class Example
{
  int a;
  public:
    void print() {}
    double c;
  private:
    string d;
  protected:
    vector<int> e;
  public:
    int square(int a) {}
};
```

---

## Наследование
Наследование - механизм, позволяющий классам копировать поля других с возможностью их изменения.

Таким образом, выстраивается некая иерархия. Определим на будущее некоторые понятия:

* Суперкласс (класс-предок) - класс, от которого наследуются
* Субкласс (подкласс, дочерний класс) - класс, который наследуется

P. S. Простите, но да, по-русски обычно говорят так, как написано в скобках. Но по-русски о программировании обычно не говорят, поэтому предпочтение отдано английским названиям.

---

Проще всего продемонстрировать это на примере. Пусть у нас описан класс игрока:
```python
class Player:
    def __init__(self):
        self.health = 100
        self.defense = 50

        self.melee_dmg = 10  # урон в ближнем бою

    def attack_melee(self, other):
        '''Атаковать игрока other в ближнем бою'''
        other.health -= (1 - other.defense / 100) * self.melee_dmg
        other.defense -= 1
```

В определенный момент игроку предоставляется возможность выбрать специализацию боя: стать воином или лучником.  

---

Можно было бы воспользоваться чудесными `Ctrl-C + Ctrl-V` и реализовать отдельно классы воина и лучника на основе класса игрока. Но это плохо по многим причинам, например:

* если вам захочется изменить одно из свойств игрока, вы рискуете забыть внести эти изменения в скопированный код
* в общем, плохой практикой является написание одного и того же больше одного раза. Код должен быть содержательным

Поэтому мы можем лучше. И в этом нам поможет механизм наследования.

На самом деле, синтаксис описания классов в Python позволяет после названия класса в скобках еще задать суперклассы. По умолчанию все классы наследуются от класса `object` стандартной библиотеки, но явно прописывать это необязательно. Таким образом, следующие варианты первой строки описания класса являются допустимыми и равнозначными:

- `class MyClass:`
- `class MyClass():`
- `class MyClass(object):`

---

Но давайте же наконец рассмотрим пример описания класса воина с помощью наследования:
```python
class Player:
    def __init__(self):
        self.health = 100
        self.defense = 50

        self.melee_dmg = 10  # урон в ближнем бою

    def attack_melee(self, other):
        '''Атаковать игрока other в ближнем бою'''
        other.health -= (1 - other.defense / 100) * self.melee_dmg
        other.defense -= 1

class Warrior(Player):
    def __init__(self):
        super().__init__()
        self.defense += 25
        self.melee_dmg += 20
```

Здесь мы видим, что класс `Warrior` наследуется от класса `Player` и переопределяет метод-конструктор.

---

Новым элементом здесь является некий вызов `super()`. Это глобальная функция, возвращающая отсылку к суперклассу текущего объекта (который `self`). То есть вызов `super().__init__()` фактически говорит:  
> Вызови конструктор суперкласса с моим объектом `self` в качестве первого аргумента

При этом метод суперкласса можно вызывать и после модификации объекта.

Если последние строчки были не очень понятными, следующий пример все прояснит (точнее, он очень постарается):
```python
class Empty:
    def __init__(self):
        if hasattr(self, something):
            print(self.something)

class NotEmpty(Empty):
    def __init__(self):
        self.something = 'Hello, World!'
        super().__init__()

Empty()  # ничего не выведется
NotEmpty()  # Hello, World!
```

---

`hasattr(obj, attr)` - еще одна глобальная функция, проверяющая, есть ли у объекта `obj` поле с именем `attr` (от английского _has attribute_).

Однако, просто изменять начальные свойства - не очень интересное применение наследования. В субклассе мы можем расширить функционал суперкласса, например, определив еще один метод и свойства, как это сделано в описании класса лучника:

```python
class Archer(Player):
    def __init__(self):
        super().__init__()
        self.defense -= 25

        self.ranged_dmg = 30  # урон в дальнем бою
        self.arrows = 100 # кол-во стрел

    def attack_ranged(self, other):
        if self.arrows == 0:
            print('Кончились стрелы, атака неудачная')
            return

        other.health -= (other.defense / 100) * self.ranged_dmg
        other.defense -= 2
        self.arrows -= 1
```

---

### C++
Синтаксис для задания суперклассов следующий:

```cpp
class Base
{
  // ...
};

class Derived: access_keyword Base
{
  // ...
};
```

`access_keyword` может принимать значения `public`, `protected`, `private` и будет регулировать уровень доступа для публичных полей суперкласса. Если опустить `access_keyword`, по умолчанию будет `private`.

---

Механизм наследования в С++ чуть менее гибок в том плане, что переопределяя в субклассе метод, вам не дано решать, вызывать ли при этом этот метод в суперклассе и, если да, то когда.

```cpp
class Base
{
  void method()
  {
    cout << "Base class\n";
  }
};

class Derived:  Base
{
  void method()
  {
    cout << "Derived class\n";
  }
};
```

Тогда при вызове `Derived().method()` выведется:
```
Base class
Derived class
```

---

## Множественное наследование
![](static/penguitten.jpg)

Наследовать поля можно от нескольких классов.

---

Python  

```python
class Derived(Base1, Base2, Base3):
```

C++  

```cpp
class Derived: access_keyword Base1, access_keyword Base2 {};
```

Позицией класса в перечислении суперклассов определяется его позиция в _порядке поиска полей_:
1. Ищи поле у инстанса
2. Ищи поле у класса этого инстанса
3. Ищи поле у первого суперкласса этого класса
4. Ищи поле у второго суперкласса этого класса
5. ...
6. Бросай исключение `AttributeError`

---

Например:

```python
class Base1:
    a = 1
    b = 2

class Base2:
    a = 3
    c = 4

class Derived(Base1, Base2):
    d = 1337

obj = Derived()
print(obj.a, obj.b, obj.c, obj.d)  # 3 2 4 1337
```

---

## Док-строки (docstrings)
Если вы пользуетесь каким-то классом, функцией, библиотекой (необязательно из стандартной библиотеки) и вам нужно получить информацию о том, чем вы пользуетесь, было бы очень кстати иметь небольшую документацию. Хороший Python-программист может предоставить эту документацию прямо в коде с помощью док-строк.

Док-строка - строковый литерал, находящийся в первой строке описания класса, функции, модуля.

Строковые литералы:

```
'string'
"another string"
# многострочные строки
'''string that spans
two lines'''
"""another
multiline string"""
```

---

```python
class Archer(Player):
    '''Игрок, обладающий способностью ведения дальнего боя.
    Имеет чуть менее сильную защиту, чем обычный игрок'''
    # описание класса

def average(a, b):
    '''Вычисляет среднее арифметическое двух чисел a и b'''
    return (a + b) / 2
```

Док-строки модулей располагаются в первой строке .py файла.

Эту строку можно получить, вызвав стандартную функцию `help()`, принимающую любой объект:

```python
help(Archer)
help(average)
import math
help(math)
```

У этой функции довольно подробный вывод, поэтому он опущен здесь для краткости.
