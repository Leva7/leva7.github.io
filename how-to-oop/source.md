# Объектно-ориентированное программирование

## Немного повторения (или...)
_Класс_ - формальное описание чего-либо, выделяющее те его аспекты, которые важны в данном контексте (при решении данной задачи).
Класс порождает объекты.

Я могу в дальнейшем использовать слово "инстанс" (instance, экземпляр), обращаясь к объектам класса. Делается это для того, чтобы отличать объект конкретного класса от просто объекта, а также чтобы для вас привычнее выглядели некоторые сообщения об ошибках в Python.

**Неформально**: класс - это чертеж, по которому вы можете построить сколько угодно объектов

---

_Например_: в некоторой задаче важно, что у объекта четыре ножки. Остальные параметры нас не интересуют. В программировании мы можем создать такой объект, в реальной жизни - нет, потребуется больше информации

Таким образом, при создании классов достаточно описать что-то абстрактное, обладающее требуемыми свойствами, описывать все свойства стола ни к чему (да и невозможно)

В нашем примере мы можем представить объект с четырьмя ножками как стол, стул, чихуахуа и т. д.

---

## Как мы хотим описать объект, о котором думаем?

- внешний вид (цвет, размеры)
- внутреннее состояние (текущее время)
- действия, которые может выполнять этот объект
- что-нибудь еще?

![](https://pbs.twimg.com/profile_images/668825520109461505/Efj36TU4_400x400.png)
---

Все пункты описания объектов можно разбить на две категории:
- данные
- алгоритмы

Мы привыкли использовать переменные для хранения данных и функции для записи алгоритмов. В ООП та же схема приобретает чуть другие названия:

* Переменные класса/объекта называются его _свойствами_
* Функции класса/объекта называются _методами_

_Поля_ класса/объекта - совокупность свойств и функций, для краткости

---

## Лирическое отступление: каноны именования
Для того, чтобы названия в коде были понятными, они часто состоят из нескольких слов. Пробел в именах использовать нельзя, как тогда их разграничивать?

Есть три общепринятые схемы:

* `нижняяВерблюжьяНотация` (`lowerCamelCase`)
* `ВерхняяВерблюжьяНотация` (`UpperCamelCase`)
* `нижние_подчеркивания` (`underscores_name`)

В языке Python принято писать названия классов _верхней верблюжьей нотацией_, названия методов, функций, переменных - _нижними подчеркиваниями_.
Нижнюю верблюжью нотацию рекомендуется не использовать.

Каждый язык задает свои каноны именования

---

## Как описать класс?
### Python
В Python описание класса начинается с ключевого свойства `class`, далее следует имя класса и двоеточие, после чего на следующем уровне отступов идет описание класса

Синтаксис описания выглядит следующим образом:

```python
class ClassName:
    # Блок кода
    pass
```

---

### C++
В С++ описание класса начинается с ключевого свойства `class` или `struct` (о различиях поговорим позже), далее следует имя класса, затем блок кода в фигурных скобках и **точка с запятой**.

```cpp
struct ClassName
{
  // Блок кода
};
```

**Яростная заметка C++-программиста** (спасибо Егору Потапенко) - через ключевое слово `struct` описывается структура, а не класс. По канонам C++ структуры используются только для хранения данных, методы в них описывать можно, но не стоит.

---

## С неба на землю
Важно понимать, что, создав класс, вы **не переходите** на волшебную территорию, где неприменимы привычные правила и нужно действовать лишь по строгим указаниям.

Что это означает? То, что под "блоком кода" в прошлых примерах я серьезно подразумеваю произвольный блок кода.

В Python внутри описания классов можно:

* создавать переменные
* описывать функции
* импортировать другие библиотеки
* считать произвольные выражения
* _о боже_, описывать классы

---

```python
class A:
    from math import log2
    if log2(4) != 2:
        print('wait, what')

    for i in range(10):
        a = i + 1

    class B:
        pass

print(A.B)  # <class '__main__.A.B'>
print(log2(8))  # ой, NameError
```

Иными словами, это самый обыкновенный блок кода (из чего следует, что у него своя область видимости, поэтому на примере кода, приведенном выше, возникла ошибка при обращении к `log2`)

В C++ тоже можно творить все, что угодно, внутри описания, даже использовать директивы вроде `#include` (хотя понятия не имею, кому это может понадобиться)

---

## С земли на дно
В Python _класс - это объект_

![](https://i01.fotocdn.net/s15/43/public_pin_m/64/2393784106.jpg)

---

А объект, как правило, лежит в переменной. А что можно делать с переменной, думаю, объяснять не требуется

```python
class A:
    # некоторое описание
    pass

B = A  # Ура, теперь есть класс B, абсолютно идентичный классу A
A = int  # Ура, теперь можно создавать числа с помощью класса A
B = 5  # Больше нету упоминаний о том классе, поэтому этот класс уничтожается
```

Функции, кстати, тоже объекты. Почти все в Python - это объекты

---

## Давайте же создадим объект
Делается это просто - оператором вызова, примененным к объекту "класс". По аналогии, вызов функции - это применение оператора вызова к объекту "функция"

```python
class MyClass:
    # Пустой класс
    pass

a = MyClass()
         # ^^ - оператор вызова
```

Теперь у нас есть объект пустого класса. Естественно, он ничего не умеет и не несет информации.

---

## Жизненный цикл объекта

Для объекта есть три основных стадии жизни:

- создание
- существование
- уничтожение

На всех трех стадиях можно заставить объект выполнять какой-то код. Например, на этапе создания можно выставить некоторые свойства для этого конкретного объекта

---

## Конструктор
При создании объекта вызывается особый метод класса - конструктор.
Особый он только названием, по сути от остальных методов он не отличается

### C++
В этом языке конструктор называется именем класса, а также не имеет явного типа возвращаемого значения.

То есть, мы привыкли писать функции как-то так:
```cpp
ReturnType function_name() {}
```

---

Внутри класса можно описать конструктор так, без всякого `ReturnType`:
```cpp
struct Player
{
  Player(string name)
  {
    cout << "Hello, " << name << endl;
  }
};
```

Теперь при создании объекта в консоль будет печататься его имя:
```cpp
Player p = Player("Lev");  // выводится Hello, Lev
```

---

### Python
Python немного противоречив в этом плане, так как в качестве конструктора рекомендуется использовать метод `__init__`, который не является конструктором.

Конструктором в Python на самом деле является метод `__new__`, но он нас не интересует

```python
class Player:
    def __init__(self, name):
        print('Hello,', name)

me = Player('Lev')  # выводится Hello, Lev
```

> Эй, а что еще за `self`? В примере C++ конструктор принимал только один аргумент, имя игрока!

---

Таким образом, мы подобрались к особенностям описания методов в Python.
Все (почти) методы принимают, по меньшей мере, один аргумент - объект, от которого вызывается метод.

Этому аргументу многолетними соглашениями было присвоено имя `self`. Вы не обязаны называть его именно так, но если вы назовете его по-другому, другие программисты вас, мягко говоря, не похвалят.

> Если вы так сделаете, люди будут вас ненавидеть, и вас будут презирать друзья и семья  
  — Scott Chacon

---

Рассмотрим на примере. Как-то так могло бы выглядеть описание известного вам метода строк - `.count()`:
```python
class str:
    # ...
    def count(self, char):
        cnt = 0
        for i in self:
            if i == char:
                cnt += 1
        return cnt
    # ...
```

---

## Состояние объекта
Разумеется, просто выводить приветствие при создании объекта - не самое креативное применение для конструктора и вообще ООП.

В конструкторе мы можем, например, зафиксировать имя игрока, а также установить какое-нибудь состояние:

### Python
```python
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

me = Player('Lev')
print(me.name)  # Lev
me.inventory.append('money')  # Вызываем метод .append() класса list
```

---

```python
# Тот же код, дублирован для наглядности
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

me = Player('Lev')
```

Рассмотрим поподробнее, что же произошло в конструкторе
```python
self.inventory = []
```

Мы знаем, что `self` - наш инстанс класса Player (тот самый, что окажется в переменной `me` после выполнения конструктора)  
Что же случилось дальше? Дальше с помощью оператора доступа (точка) мы обратились к свойству `inventory` нашего инстанса. Это свойство находится в левой части присвоения, поэтому Python нисколько не смущает то, что он не нашел у инстанса свойство `inventory` - он его попросту создал.

Таким образом, мы научились создавать свойства и получать их значения

---

#### Опять на землю
В этом куске кода тоже не было ничего, что может быть только в классе. Например, после создания объекта мы можем создать свойство лично у него:

```python
class Player:
    pass

me = Player()
me.name = 'Lev'

you = Player()
print(you.name)
```
> Но ведь у инстанса `you` нету имени...

Правильно, нету:  

`AttributeError: 'Player' object has no attribute 'name'`

---

А еще мы знаем, что по сути объект класса `Player` особо не отличается от объектов классов `list`, `str`, и т. д.
А это значит, что:

```python
ls = []
ls.name = 'My List'

def func():
    pass

func.name = 'My Function'

def show_name(obj):
    print(obj.name)

show_name(ls)  # My List
show_name(func)  # My Function
```

Но достаточно играться с динамической натурой Python.

---

### C++
В С++ все строго - для того, чтобы задать свойство, нужно его сначала объявить.

```cpp
struct Player
{
  string name;
  vector<string> inventory;  // По умолчанию инициализируется
                             // пустым вектором для каждого инстанса

  Player(string name)
  {
    this->name = name;
  }
};

int main()
{
  Player me = Player("Lev");  // Еще можно записать то же
                              // самое так: Player me("Lev");
  cout << me.name << '\n';  // Lev
  me.inventory.push_back("money");  // Вызываем метод push_back класса vector
}
```

---

> А это что за ужас, что за this, стрелочки какие-то, сложно

Да, С++ не очень располагает к себе в этом плане.  
Внутри методов есть переменная `this`, являющаяся аналогом `self` в Python.  
Оператор "стрелочка" (`->`) - аналог оператора доступа "точка", но для указателей. Да, `this` - это только указатель на объект

Таким образом, эту строку  
```cpp
this->name = name;
```  
можно было бы написать и так:  

`*(this).name = name;`

И тут уже нельзя будет написать что-то вроде этого без предварительного объявления внутри класса переменной `int health`.
```cpp
Player me = Player("Lev");
me.health = 100;
```

---

## Описание произвольных методов
Теперь, когда мы умеем описывать конструктор и сохранять в объекте данные, можно попробовать описать и другие методы.

Вернемся к нашему игроку:
```python
class Player:
    def __init__(self, name):
        self.name = name  # ник игрока
        self.health = 100  # здоровье
        self.inventory = []  # инвентарь

    def pick_up(self, item):
        self.inventory.append(item)

    def drop_stuff(self):
        self.inventory.clear()
```

---

И вот как с этим классом теперь можно обращаться:

```python
me = Player('Lev')
me.pick_up('money')  # Вызываем метод pick_up,
                     # передавая строку 'money' в качестве параметра

you = Player('Not Lev')
you.pick_up('knowledge')
you.pick_up('patience')

print(me.inventory, you.inventory)  # ['money'] ['knowledge', 'patience']
me.drop_stuff()
print(me.inventory == [])  # True
```

---

В С++ дела обстоят почти идентично, только аргументам методов нужно прописывать тип, а методам - тип возвращаемого значения:
```cpp
struct Player
{
  string name;
  vector<string> inventory;

  Player(string name)
  {
    this->name = name;
  }

  void pick_up(string item)
  {
    this->inventory.push_back(item);
  }
  // ...
};

// ...
```

---

## Упражнение, условие
Программист может осуществлять два вида деятельности:

1. Писать код.
2. Пить кофе.

Когда программист пишет код, он устает. Поэтому на каждую следующую строчку
кода он тратит больше времени, чем на предыдущую. Если программист выпивает
чашку кофе, он восстанавливает работоспособность, но, к сожалению, после каждой
чашки кофе начинает все быстрее уставать.  

Начинает писать код программист отдохнувшим, поэтому первую строчку кода пишет
за 1 минуту. Если он не будет пить кофе, то каждую следующую строчку кода он
будет писать на 1 минуту дольше, чем предыдущую.  

После написания любой строчки кода он может выпить чашку кофе. После того, как
программист выпьет чашку кофе, очередную строчку кода он опять напишет всего за
одну минуту, но на каждую последующую будет тратить уже на N минут больше, чем
на предыдущую, где N зависит от того, какая это по счету чашка кофе, выпитая
программистом. После первой выпитой чашки кофе, N становится равно 2, после
второй – 3, после третьей – 4, а после четвертой - 5. При этом на то, чтобы выпить
любую чашку кофе, программист тратит 5 минут.

---

## Упражнение, постановка задачи

Создать класс `Coder`, поддерживающий следующее состояние:

* кол-во написанных строк кода
* кол-во выпитых чашек кофе
* время, которое потратил программист, в минутах
* усталость (влияет на скорость написания кода)

Описать в нем методы:

* написать строку кода
* выпить чашку кофе
* информация (вывести "На момент времени {} написано {} строк кода и выпито {} чашек кофе", заменяя {} на соответствующие свойства класса)

Класс должен действовать в соответствии с условием задачи, описанным на предыдущем слайде  
_Задание частично взято из тренировочной сессии ИТМО_

Сдать задание можно в [этот classroom](https://repl.it/classroom/invite/KZNtdaz), assignment "Уставший программист"
